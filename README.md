# 프로젝트 개요

이 프로젝트는 이벤트 조건 검증 및 보상 지급을 자동화하는 MSA 기반 시스템입니다.
NestJS + MongoDB + Kafka를 사용하여 인증, 이벤트 처리, 보상 요청 흐름을 구성하였으며,
메이플스토리 실서비스 수준의 트래픽을 가정하여 구조를 설계하였습니다.

- 기술 스택: NestJS, MongoDB, Kafka, Docker
- 아키텍처: Auth Server / Event Server / Gateway Server (MSA)
- 주요 특징: 조건 기반 보상, 메시지 큐 기반 비동기 처리, 멱등성/동시성 제어, RESTful API 설계

---

# 1단계: 문제 이해 및 설계 범위 확정

## 문제 요약 및 과제 목적

이 과제는 이벤트 조건 검증과 보상 지급의 수작업 문제를 해결하기 위한 자동화 시스템 구축이 목적이며, 실제 서비스 적용 가능성을 염두에 두고 설계했습니다.

이벤트 조건 충족 여부 확인과 보상 지급이 엑셀 기반 수작업으로 진행되고 있어 자동화 및 효율화가 필요합니다.

사용자 역할별 기능 제한과 감사 로그 확인 기능이 필수 요구사항입니다.

인증 및 권한은 JWT 기반으로 처리해야 하며, MSA 환경에서의 역할 분리와 책임 분담이 핵심입니다.

## 실서비스 수준 트래픽 가정

실제 게임 서비스 환경을 고려하여, 2011년 메이플스토리의 최고 동시 접속자 수 62만 명을 기준으로 일일 요청량과 QPS(초당 요청 수)를 추정했습니다.

### 이벤트 흐름 및 요청 가정

| 단계                  | 설명                                                     | 일일 요청 수 추정 |
| --------------------- | -------------------------------------------------------- | ----------------- |
| 1. 로그인 → 자동 참여 | 로그인 시 자동으로 이벤트 참여 처리                      | 620,000           |
| 2. 진행도 확인        | 유저 1일 1회 상태 조회                                   | 620,000           |
| 3. 이벤트 완료 신청   | 1/3 유저가 당일 조건 만족 후 신청                        | 약 206,666        |
| 4. 보상 수령 요청     | 보상 수령은 부분 수령 허용, 아이템 종류별 다회 요청 발생 | -                 |

### 보상별 수령 횟수 가정

| 아이템명        | 예상 수령 횟수 | 총 요청 수  |
| --------------- | -------------- | ----------- |
| 극한성장의 비약 | 5회            | 1,033,330   |
| 코어 잼스톤     | 3회            | 619,998     |
| 사우나 이용권   | 1회            | 206,666     |
| 총합            | -              | 1,859,994건 |

### 서버별 QPS 계산 (일반 시간대 & 피크 시간대)

### 1. Auth Server

#### 주요 기능

- 로그인 처리 (JWT 발급)
- 로그인 1건당 1회 요청 발생

#### 요청량 가정

- 유저 수: 620,000명/일
- 유저당 로그인: 1회/일  
  → **일일 로그인 요청 수 = 620,000건**

#### QPS 계산

| 기준        | 요청 수 | QPS (초당)              | 피크 QPS (×3) |
| ----------- | ------- | ----------------------- | ------------- |
| 로그인 처리 | 620,000 | 620,000 ÷ 86,400 ≈ 7.17 | 21.51         |

---

### 2. Event Server

#### 주요 기능

- 로그인 성공 시 진행도 증가 요청 수신
- 유저 진행도 조회
- 이벤트 완료 신청
- 보상 수령 (부분 수령 포함)

#### 요청량 가정

| 기능               | 요청 수 (일간) | 설명                             |
| ------------------ | -------------- | -------------------------------- |
| 로그인 진행도 증가 | 620,000        | Auth Server에서 전송             |
| 유저 진행도 조회   | 620,000        | 유저가 1일 1회 조회              |
| 이벤트 완료 신청   | 206,666        | 1/3 유저가 완료 후 신청          |
| 보상 수령 요청     | 1,859,994      | 비약 5회, 잼스톤 3회, 사우나 1회 |

#### QPS 계산

| 기능               | 요청 수   | QPS (초당) | 피크 QPS (×3) |
| ------------------ | --------- | ---------- | ------------- |
| 로그인 진행도 증가 | 620,000   | 7.17       | 21.51         |
| 유저 진행도 조회   | 620,000   | 7.17       | 21.51         |
| 이벤트 완료 신청   | 206,666   | 2.39       | 7.17          |
| 보상 수령 요청     | 1,859,994 | 21.52      | 64.56         |

**→ Event Server 총합 QPS**

| 구분     | QPS (일반) | QPS (피크 ×3) |
| -------- | ---------- | ------------- |
| **합계** | **38.25**  | **114.75**    |

---

### 최종 요약

| 서버          | 일반 QPS      | 피크 QPS (×3)  |
| ------------- | ------------- | -------------- |
| Auth Server   | 7.17 QPS      | 21.51 QPS      |
| Event Server  | 38.25 QPS     | 114.75 QPS     |
| **전체 합계** | **45.42 QPS** | **136.26 QPS** |

### 설계 범위 결론

메이플스토리의 최고 동시 접속자 수(62만 명)를 기준으로 추정한 결과, Event Server는 최대 140 QPS 수준의 트래픽을 처리해야 할 것으로 예상됩니다.

이벤트 서버는 진행도 기록, 완료 신청, 보상 수령, 이력 저장까지 전담합니다.

인증/권한 검증은 게이트웨이와 인증 서버에 위임하여 도메인 로직에 집중된 구조로 설계하였습니다.

---

# 2단계: 개략적 설계 및 시나리오 제시

## 아키텍처 개요

이 시스템은 3개의 서버로 구성된 MSA 구조를 따르며, 각 서버는 자신의 책임에만 집중하도록 설계되었습니다.

| 서버           | 책임                                                              |
| -------------- | ----------------------------------------------------------------- |
| Auth Server    | 유저 등록, 로그인 처리, 역할(Role) 관리, JWT 발급                 |
| Gateway Server | 모든 요청의 진입점. JWT 토큰 파싱 및 권한 검증, 요청 라우팅       |
| Event Server   | 이벤트 생성, 유저 이벤트 진행도 추적, 보상 지급 처리 및 이력 저장 |

**서비스 흐름**

```text
Client

↓ (1) 로그인 요청

Gateway Server

↓ (2) 로그인 요청 위임

Auth Server

↓ (3) 로그인 성공 → Access/Refresh Token 발급

Gateway Server

↓ (4) 이후 모든 요청에서 토큰 검증 + 권한 확인

↓ (5) 사용자 이메일을 헤더로 삽입하여 이벤트 서버로 요청 전달

Event Server

↓ (6) 비즈니스 로직 처리 (추가 인증/필터링 없음)
```

## 설계 원칙

**1. 책임 분리**

- Auth Server는 오직 인증과 역할 관리를 담당하며, 비즈니스 로직에는 관여하지 않습니다.
- Gateway Server는 유일한 API 진입점으로, 토큰 유효성 검사 및 역할에 따른 요청 필터링을 수행합니다.
- Event Server는 “비즈니스 처리 전용 서버”로, 들어오는 요청은 이미 인증된 것으로 간주하고 추가 검증 없이 처리합니다.

**2. 보안과 신뢰**

- Event Server는 외부 요청을 직접 받지 않으며, Gateway Server를 통해서만 요청이 들어옵니다.
- Gateway Server는 Auth Server로부터 발급받은 JWT 토큰을 파싱하여 사용자 정보를 확보하고, 유효성 검사 및 권한 제한을 사전에 수행합니다.
- Event Server는 오직 헤더의 이메일 정보만을 바탕으로 동작하며, 별도의 유저 검증 로직은 존재하지 않습니다.

**3. 확장성 고려**

- 각 서버는 독립적으로 배포 및 확장 가능 합니다.
- 인증 서버 또는 이벤트 서버의 부하를 기준으로 개별적으로 스케일 아웃 가능 합니다.

## 이벤트 흐름 시나리오: 로그인 이벤트

현재 구현된 이벤트 종류는 **로그인 이벤트**이며, 다음과 같은 흐름으로 동작합니다.

### 1. 이벤트 등록 및 보상 구성

- 운영자가 로그인 이벤트를 생성합니다.
- 이벤트에 여러 종류의 **보상**을 사전 등록할 수 있습니다.
- 각 보상은 다음 필드를 포함합니다:
  - `이름` (예: 극한성장의 비약)
  - `종류(type)` (예: 아이템, 포인트 등)
  - `수량(amount)`

예시:

- 극한성장의 비약: `100개`
- 코어 잼스톤: `100개`
- 사우나 이용권: `5개`

### 2. 유저 로그인 → 이벤트 자동 참여

- 유저가 로그인하면, **Auth Server**가 **Event Server**로 유저의 로그인 사실을 전송합니다.
- 유저는 별도의 참여 버튼 없이 **자동으로 이벤트에 참여**됩니다.
- **진행도는 누적**되며, 조건(예: 로그인 3회)을 만족하면 이벤트 완료 신청이 가능합니다.

### 3. 유저의 이벤트 완료 신청

- 유저가 조건을 만족하면, 명시적으로 **이벤트 완료 신청**을 해야 합니다.
- 조건 검증은 Event Server가 수행합니다.
- 검증 후, 유저는 **보상을 수령할 수 있는 상태**가 됩니다.

### 4. 보상 수령 요청

- 보상은 **종류별로** 수령 가능합니다.
- 다음 두 가지 방식이 지원됩니다:

#### 부분 수령

- 특정 보상 일부만 수령
- 예: `극한성장의 비약 100개 중 20개만 수령`

#### 일괄 수령 (단일 보상 종류에 한함)

- 보상 종류 하나를 전량 수령
- 예: `코어 잼스톤 100개 전체 수령`

**주의사항**

- 여러 보상 종류는 **한 번에 수령할 수 없습니다.**
- 예:
  - `극한성장의 비약 + 코어 잼스톤` → 한 요청에서 수령 **불가**
  - 각각 별도 요청 필요

## API 설계

본 프로젝트의 API는 **RESTful 원칙**을 최대한 준수하여 설계하였습니다.

- **자원(Resource) 기반 URL 구조**를 따릅니다.
- 현재는 **HTTP 메서드 중 GET과 POST만 사용**하고 있습니다.
- 각 API는 **사용자 역할(Role)**에 따라 접근 권한이 다르게 적용됩니다.

### Swagger 문서

서버 실행 후, 아래 주소를 통해 각 서비스의 Swagger 문서에 접근할 수 있습니다:

- **Event Server**: [http://localhost:3001/api-docs](http://localhost:3001/api-docs)
- **Auth Server**: [http://localhost:3000/api-docs](http://localhost:3000/api-docs)

> ※ 위 주소는 개발 환경에서만 접근 가능하며,  
> **실제 클라이언트 요청은 Gateway Server(포트 3002)를 통해 이루어집니다.**

### 요청 예시 (Proxy 경유 흐름)

예를 들어, 이벤트 목록을 조회하는 API는 Event Server에 다음과 같이 정의되어 있습니다:
**GET http://localhost:3001/events?page=1&limit=10**

그러나 실제 클라이언트는 **Gateway Server를 통해 동일한 요청을 아래처럼 전송**해야 합니다:
**GET http://localhost:3002/events?page=1&limit=10**

> Gateway Server는 내부적으로 요청을 **Event Server 또는 Auth Server로 자동 라우팅**합니다.

## 구현 범위 관련 안내

본 과제는 **핵심 흐름과 자동화 구조 설계에 집중**하기 위해,  
다음 기능은 의도적으로 구현하지 않았습니다:

- 이벤트 삭제 API
- 보상 삭제/수정 API
- 유저 진행도 삭제/수정 API

이유는 다음과 같습니다:

- 과제의 목적은 **이벤트 조건 검증 및 보상 처리 자동화 시나리오**에 중점을 두고 있으며,
- 위 기능은 **운영/관리 목적의 부가 기능**으로 간주되므로 **필수 요구사항에서 제외**된다고 판단했습니다.

#### 확장 고려 사항

실제 서비스 전환 시에는 다음과 같은 방식으로 확장 가능하도록 구조를 설계하였습니다:

- 운영자 전용 삭제/수정 API 추가
- **Soft Delete** 적용 (상태 기반 비활성 처리)
- 보상 및 이벤트 상태 변경 기능 등

---

# 3단계: 상세 설계 및 설계 주요 고려사항

본 단계에서는 전체 시스템 구조 설명보다는,  
설계 시 중점적으로 고려한 주요 지점들을 중심으로 설명합니다.

**특히 다음과 같은 측면에 대해 실무적 판단과 의도를 담아 구조를 설계하였습니다.**

- 로그인 이벤트 트리거 처리
- 로그인 이벤트 전달 방식
- 보상 수령 요청의 중복 방지 및 동시성 제어

## 1. 로그인 이벤트 트리거 처리 설계 (Auth Server → Event Server)

#### 문제

이벤트 조건이 로그인 횟수 기반일 경우, 로그인이라는 행동은 Auth Server에서만 인지할 수 있습니다.  
반면, 실제 이벤트의 진행도 상태는 Event Server에서 관리되어야 하므로 두 서버 간의 연동이 필요합니다.

### 해결 방안

Auth Server는 로그인 성공 시, Event Server로 유저 이메일이 포함된 `"진행도 증가 요청"`을 전송합니다.  
Event Server는 이를 신뢰하고, 해당 유저의 진행도를 `+1` 증가시킵니다.  
조건(예: 로그인 3회)을 만족했는지 여부는 Event Server 내부에서 판단합니다.

### 설계 의도

- **행동 트리거는 발생한 서버(Auth)** 에서 발생시키고,
- **진행 상태 판단과 저장은 책임 주체(Event)** 에서 처리하도록 설계하여  
  **서버 간 책임을 명확히 분리**하였습니다.

클라이언트가 직접 진행도 변경을 요청하지 않도록 하여, **조작 방지와 신뢰성**을 확보하였습니다.

이 구조는 향후 유저 행동 기반 이벤트 전반에 대한 확장성을 고려한 설계입니다.

## 2. 로그인 이벤트 전달 방식: 메시지 큐 도입 배경

### 문제

Auth Server가 Event Server에 `"로그인 이벤트 발생"`을 알릴 때,  
전달 방식에 따라 **서버 간 결합도, 신뢰성, 성능**에 큰 영향을 미칩니다.

### 고려했던 방식 및 설명

| 방식                                       | 설명                                                                           | 한계                                                                            |
| ------------------------------------------ | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------- |
| HTTP 동기 요청                             | 로그인 성공 직후, Auth Server가 Event Server에 HTTP 요청 전송                  | Event Server가 느리거나 장애 발생 시 인증 서버까지 영향을 받아 전체 신뢰도 저하 |
| HTTP 비동기 요청                           | 인증 서버에서 요청만 보내고 응답은 기다리지 않음                               | 처리 성공 여부 확인 불가, 유실 위험 존재, 신뢰성 낮음                           |
| 메시지 큐 기반 비동기 처리 (**최종 선택**) | Auth Server는 Kafka 등 메시지 브로커에 메시지를 발행, Event Server는 이를 구독 | 결합도 낮고, 재시도·확장성·모니터링 모두 유리                                   |

---

### 도입한 구조: 메시지 큐 기반 아키텍처

- 로그인 성공 시, **Auth Server**는 Kafka에 메시지를 발행
- **Event Server**는 이를 구독하고, 유저의 로그인 진행도를 **비동기적으로 증가**
- 메시지 전송 실패나 Event Server 장애 발생 시에도 **DLQ(Dead Letter Queue)** 및 **재시도 메커니즘**을 통해 복구 가능
- 각 서버는 서로의 상태에 영향을 받지 않고 **독립적으로 동작**

### 설계 의도 및 효과

- **결합도 해소**: 직접 호출 없이 이벤트 기반 연동으로 책임 분리
- **신뢰성 확보**: 메시지 유실 최소화 및 재처리 가능
- **확장성 강화**: 고부하 상황에서도 병목 없이 수평 확장 대응 가능
- **관측성 향상**: 메시지 추적 및 모니터링 가능, 운영 안정성 확보

## 3. 보상 수령 요청의 중복 방지 및 동시성 제어

### 문제

이 API는 유저가 이벤트 조건을 만족했을 때, 특정 보상을 수령하도록 처리합니다.  
보상은 같은 종류를 **여러 번에 나누어 수령**할 수 있기 때문에, 다음과 같은 상황을 방지하는 것이 핵심입니다:

- 동일 보상에 대한 **중복 요청**이 처리될 수 있습니다.
- 보상 수량이 충분하지 않은데,
  동시에 들어온 여러 요청이 모두 “지급 가능”하다고 판단되면,
  실제로는 **수량을 초과해서 지급되는 문제(중복 처리)**가 발생할 수 있습니다.

### 1) 초기 설계: 정규화 기반 구조

초기에는 각 보상 요청을 **별도의 도큐먼트**로 저장했습니다.

예시:

```json
{
  "eventId": "event123",
  "email": "user@example.com",
  "rewardName": "코어 잼스톤",
  "amount": 100,
  "status": "SUCCESS",
  "requestId": "req-uuid-123"
}
```

### requestId를 기준으로 멱등성(idempotency) 보장

- 각 보상 요청에 대해 고유한 `requestId`를 부여하여 **중복 수령을 방지**합니다.
- 정규화된 구조에서는 다음과 같은 장점이 있습니다:
  - 쿼리/정렬/페이징 등에서 **유연하게 활용 가능**
  - 각 요청 단위로 **상태 추적**이 명확함

### 그러나 다음과 같은 한계가 존재했습니다:

#### 문제점

- 유저가 보상을 **종류별 한개씩 번요청**하는 경우(최악의 경우 가정)  
  → 유저당 최대 `수백개의 도큐먼트` 발생
- 유저 수가 60만 명이라면  
  → 전체 **수억 건의 도큐먼트**로 확장될 수 있음
- **보상 잔여 수량 계산 시**,  
  → 매번 `aggregation` 연산 필요  
  → **성능 저하가 누적**

### 2) 구조 개선: 하이브리드 모델 도입 (역정규화 + 로그 분리)

MongoDB의 철학인 **역정규화(denormalization)** 에 따라 구조를 개선했습니다.

- **`RewardClaimHistoryEntity`**  
  → 유저 단일 문서 + 보상 배열로 **실시간 조건 확인/누적 처리에 최적화**
- **`RewardClaimLogEntity`**  
  → 요청 단위 로그를 별도로 저장하여 **감사/통계/이력 추적에 용이**

이로써, 성능과 관리의 균형을 잡은 구조로 리팩토링하였습니다.

### a. `RewardClaimHistoryEntity`: 유저 단일 문서 + 보상 배열

```json
{
  "eventId": "event123",
  "email": "user@example.com",
  "rewards": [
    {
      "rewardName": "코어 잼스톤",
      "amount": 100,
      "status": "SUCCESS",
      "requestId": "req-uuid-123"
    },
    ...
  ]
}
```

- 유저 기준으로 보상 이력을 배열 형태로 누적
- 보상 잔여 수량 확인, 조건 충족 여부 판단에 매우 효율적
- 단, 배열 내 중복 요청/추가를 방지하기 위해 동시성 제어 필요

### b. RewardClaimLogEntity: 단일 요청 로그 (성공/실패 포함)

```json
{
  "eventId": "event123",
  "email": "user@example.com",
  "rewardName": "코어 잼스톤",
  "amount": 100,
  "status": "FAILURE",
  "reason": "조건 미달",
  "requestId": "req-uuid-124"
}
```

- 운영자용 로그, 통계 집계, 문제 추적용
- requestId에 유일 인덱스를 설정하여 멱등성 보장

### 3) 동시 요청 제어: Named Lock + Request ID 적용

역정규화된 배열에 데이터를 `append`하는 구조에서는,  
**동시에 들어온 요청이 모두 조건을 통과하여 중복 수령되는 문제**가 발생할 수 있습니다.

이를 방지하기 위해 **Named Lock 방식 + requestId 기반 제어**를 도입했습니다.

```ts
const lockKey = `${email}:${rewardName}`;
const acquired = lockManager.acquire(lockKey);

if (!acquired) {
  throw new ConflictException('동시 요청 중입니다.');
}
```

- 락 키 구성: `email + rewardName` 조합으로 설정
- 동작 방식
  - 같은 유저의 같은 보상은 **순차 처리**
  - 다른 유저는 **동시 처리 가능**
- 현재 환경: 단일 인스턴스 환경에서는 **`in-memory Map`** 사용
- 확장 고려: 다중 인스턴스 환경에서는 **Redis 기반 분산 Lock**으로 전환 가능
  - 예시: `SETNX`, `Redlock`

### 종합 요약

| 설계 요소                             | 목적                                   |
| ------------------------------------- | -------------------------------------- |
| `RewardClaimHistoryEntity` (역정규화) | 유저별 빠른 잔여 보상 계산, 빠른 조회  |
| `RewardClaimLogEntity` (정규화 로그)  | 전체 요청 기록, 통계 및 감사 추적용    |
| `requestId`                           | 중복 요청 방지 (**멱등성 보장**)       |
| Named Lock                            | 동시성 문제 방지, **보상 정확성 확보** |

이 설계는 **MongoDB의 역정규화 철학**을 따르면서도,  
**보상 수령이라는 민감한 기능**에서 발생할 수 있는 **중복 처리 및 경쟁 조건 문제를 효과적으로 해결**할 수 있는 구조입니다.

---

# 4단계: 프로젝트 실행 및 구조 안내

## 프로젝트 구조

```
event-reward-system/
├── auth-server/ # 인증 및 유저 역할 관리 서버
├── event-server/ # 이벤트 등록, 조건 검증, 보상 지급 서버
├── gateway-server/ # 모든 API 요청 진입점 (라우팅 및 권한 검증)
└── docker-compose.yml # 전체 서비스 통합 실행 설정 파일
```

## ▶ 실행 방법

### 1. Docker 이미지 빌드

```bash
docker compose build
```

※ 필요 시 캐시 없이 빌드하려면:

```bash
docker compose build --no-cache
```

### 2. 컨테이너 실행

```bash
docker compose up
```

### 3. Swagger 문서 접속

- **Auth Server**: [http://localhost:3000/api-docs](http://localhost:3000/api-docs)
- **Event Server**: [http://localhost:3001/api-docs](http://localhost:3001/api-docs)

> ⚠️ 실제 모든 클라이언트 요청은 **Gateway Server (포트 3002)** 를 통해 진입합니다.

예를 들어, 이벤트 목록을 조회하려면 다음과 같이 요청합니다:

```bash
GET http://localhost:3002/events?page=1&limit=10
```

## 코드 구조 설명

본 프로젝트는 **도메인 중심 설계(Domain-Centric Design)** 를 기반으로,  
각 기능(`user`, `event` 등)을 독립적인 모듈로 나누고,  
내부는 **계층별 책임**에 따라 구조화하였습니다.

이는 **Hexagonal Architecture** 의 철학을 반영한 설계로,  
도메인 로직과 외부 의존성을 명확히 구분하고  
**유지보수성**, **확장성**, **테스트 용이성**을 높이는 데 목적이 있습니다.

---

### 서버별 구성 방식

#### Gateway Server

- 역할이 단순하므로 **컨트롤러 중심 구조**로 설계
- **JWT 검증**, **권한 확인**, **요청 라우팅 처리**만 담당

#### Auth Server / Event Server

- **도메인 중심 계층 구조**로 설계
- 공통적으로 아래와 같은 디렉토리 체계를 따릅니다:

```
[src]
├── app.module.ts                            # 루트 모듈
├── main.ts                                  # 애플리케이션 진입점
├── common
│   ├── dto
│   │   └── common-response.dto.ts           # 공통 응답 DTO
│   ├── exception
│   │   ├── custom
│   │   │   └── email-already-registered.exception.ts  # 이메일 중복 예외
│   │   └── global
│   │       └── http-exception.filter.ts     # 전역 예외 필터
│   ├── kafka
│   │   └── kafka.module.ts                  # Kafka 설정 모듈
│   └── types
│       └── request-with-user.ts             # 사용자 정보가 포함된 Request 타입
├── initializer
│   ├── initializer.module.ts                # 초기 데이터 삽입용 모듈
│   └── initializer.service.ts               # 초기 데이터 삽입 로직
└── user
    ├── application
    │   ├── command
    │   │   └── register-user.command.ts     # 유저 등록 커맨드
    │   ├── dto
    │   │   └── access-token-response.ts     # 로그인 응답 DTO
    │   └── user.service.ts                  # 유저 도메인 유스케이스 처리
    ├── domain
    │   └── user.ts                          # 유저 도메인 모델
    ├── infra
    │   ├── kafka
    │   │   └── kafka.producer.ts            # Kafka 메시지 발행
    │   ├── user.entity.ts                   # MongoDB 스키마 정의
    │   ├── user.mapper.ts                   # Entity ↔ 도메인 모델 매핑
    │   └── user.repository.ts               # 유저 조회/저장 처리
    ├── user.module.ts                       # 유저 모듈 정의
    └── web
        ├── auth.controller.ts               # 회원가입/로그인 API
        ├── dto
        │   └── register-user.request.ts     # 회원가입 요청 DTO
        ├── role.controller.ts               # 역할 변경 API
        └── token.controller.ts              # 토큰 갱신 API

```

### 기타 주요 폴더

#### `common/`

- 공통 DTO, 예외 클래스, Kafka 모듈, 타입 정의 등을 포함
- 모든 도메인 모듈에서 공통으로 사용하는 유틸성 컴포넌트

#### `initializer/`

- 서버 시작 시 자동 실행되는 초기화 모듈
- `UserService`를 통해 초기 운영자 계정(`admin`)을 자동 생성하여 **편의성 확보**

---

### 정리

- 이 구조는 **기능별 모듈화 + 계층별 책임 분리**를 통해  
  서비스가 커져도 복잡성이 **모듈 내부에 국한**되도록 설계되었습니다.
- 각 계층의 책임이 명확하여 **테스트, 유지보수, 확장성** 측면에서 매우 유리한 구조입니다.

---

### 테스트 코드 실행

각 서버는 **단위 테스트(Unit Test)** 와 **E2E 테스트**를 지원합니다.  
다음 명령어를 각 프로젝트(`auth-server`, `event-server` 등)의 루트 디렉토리에서 실행하시면 됩니다:

```bash
npm run test         # 단위 테스트 실행
npm run test:cov     # 단위 테스트 + 커버리지 리포트 확인
npm run test:e2e     # E2E 테스트 실행
```
